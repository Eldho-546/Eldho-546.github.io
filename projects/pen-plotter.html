<!doctype html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://unpkg.com/prismjs@1.29.0/themes/prism-tomorrow.min.css">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Whiteboard Pen Plotter — Project Blog | Abitha</title>
  <meta name="description" content="Build log for a 2‑axis whiteboard pen plotter: goals, hardware, firmware, mechanics, problems & fixes, results, and next steps." />
  <meta name="theme-color" content="#0b0f19" />
  <style>
    /* Expandable code block */
    .code-wrap {
      position: relative;
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      background: #0e162b;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .code-wrap pre {
      max-height: 280px;       /* default height */
      margin: 0;
      overflow: auto;
      padding: 14px;
    }
    .code-wrap .fade {
      content: "";
      position: absolute;
      left: 0; right: 0; bottom: 42px;
      height: 48px;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(14,22,43,0), rgba(14,22,43,1));
      display: none; /* only show when not expanded */
    }
    .code-wrap .toolbar {
      position: absolute;
      right: 8px;
      bottom: 8px;
      display: flex;
      gap: 8px;
    }
    .code-wrap .toolbar button {
      background: rgba(255,255,255,.06);
      color: #e6e8ef;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
    }
    .code-wrap:not(.expanded) .fade {
      display: block;
    }
    .code-wrap.expanded pre {
      max-height: min(70vh, 720px);  /* bigger when expanded */
    }

    /* --- Base / tokens (matching homepage) --- */
    *,*::before,*::after{box-sizing:border-box}
    html,body{margin:0;padding:0}
    img{max-width:100%;display:block}
    a{color:inherit;text-decoration:none}
    pre,code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    :root{
      --bg: #0b0f19;
      --bg-soft: #0f1526;
      --text: #e6e8ef;
      --muted: #99a1b3;
      --brand: #8aa1ff;
      --brand-strong: #6b84ff;
      --card: #10172b;
      --ring: rgba(138,161,255,.35);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --maxw: 1150px;
      --content: 760px;
    }

    body{
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(60vw 60vw at 80% -10%, #0e1430 0%, transparent 60%),
                  radial-gradient(50vw 50vw at -10% 10%, #0b0f19 0%, transparent 60%),
                  var(--bg);
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    .shell{max-width:var(--maxw); margin:0 auto; padding: clamp(16px,2.5vw,28px)}

    /* Header / breadcrumb */
    header{display:flex; align-items:center; gap:12px; padding-block: 6px 12px}
    .crumb{ color: var(--muted); font-size:14px; display:flex; gap:8px; align-items:center }
    .crumb a{ color: var(--brand); }
    .crumb a:hover{ text-decoration: underline; }

    /* Hero */
    .hero{ margin-top:8px; background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
           border: 1px solid rgba(255,255,255,.06); border-radius: var(--radius); overflow:hidden; box-shadow: var(--shadow);}    
    .hero-media{ aspect-ratio: 16/7; background:#0a0f1f; position:relative; }
    .hero-media img,.hero-media video{ width:100%; height:100%; object-fit:cover; }
    .hero-media video{ position:absolute; inset:0; opacity:0; transition:opacity .4s ease; }
    .hero-media:hover video{ opacity:1; }
    .hero-body{ padding: clamp(16px,2.2vw,22px) }
    .eyebrow{ color: var(--brand); font-weight:650; letter-spacing:.3px; text-transform:uppercase; font-size:12px }
    h1{ margin:.3rem 0 .4rem; font-size: clamp(24px, 3.2vw, 38px); letter-spacing:.2px }
    .sub{ color: var(--muted); max-width: 70ch; margin:0 }

    /* Layout: content + aside */
    .wrap{ display:grid; gap: clamp(16px,2vw,24px); margin-top: clamp(18px,2.5vw,28px) }
    .content{ max-width: var(--content); }
    .aside{ background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
            border: 1px solid rgba(255,255,255,.06); border-radius: 16px; padding:16px; height:max-content; position:sticky; top:16px }

    @media (min-width: 980px){
      .wrap{ grid-template-columns: minmax(0, var(--content)) minmax(0, 1fr); align-items:start }
    }

    /* Article styling */
    article h2{ font-size: clamp(18px,2.4vw,26px); margin: 26px 0 8px }
    article p{ margin: 0 0 14px; color: #d7d9e2 }
    article ul{ margin: 0 0 14px 1.2rem; color:#d7d9e2 }
    .callout{ background: rgba(138,161,255,.08); border:1px solid rgba(138,161,255,.25); padding:12px 14px; border-radius:12px; }

    /* Media blocks */
    .figure{ background: #0a0f1f; border:1px solid rgba(255,255,255,.06); border-radius: 14px; overflow:hidden; box-shadow: var(--shadow); margin: 14px 0 }
    .figure img{ width:100%; height:auto; display:block }
    /* Smooth rotator + fixed sizing for hardware gallery only */
    #hardware-rotator{ position:relative; aspect-ratio: 5 / 3; }
    #hardware-rotator .slide{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; opacity:0; transition:opacity .6s ease; }
    #hardware-rotator .slide.show{ opacity:1; }
    .figcap{ font-size: 14px; color: var(--muted); padding:10px 12px }

    /* Modelled Parts (model-viewer) */
    #parts { margin: 50px 0 60px; }
    #parts .intro { color: var(--muted); max-width: 70ch; }
    .parts-grid { display:grid; gap:14px; grid-template-columns: 1fr; }
    .part-card {
      position: relative;
    }

    .part-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.12);
      color: #fff;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 10px;
      display: none; /* hidden until focused */
      z-index: 2;
    }

    /* When a card is focused */
    .parts-grid.focused .part-card { display: none; }
    .parts-grid.focused .part-card.focused {
      display: block;
      grid-column: 1 / -1;
    }
    .parts-grid.focused .part-card.focused model-viewer {
      height: min(70vh, 720px); /* taller in focus mode */
    }
    .parts-grid.focused .part-card.focused .part-close {
      display: inline-block;
    }

    @media (min-width: 720px){ .parts-grid{ grid-template-columns: repeat(2, 1fr); } }
    @media (min-width: 1040px){ .parts-grid{ grid-template-columns: repeat(3, 1fr); } }
    .part-card { position:relative; background:#10172b; border:1px solid rgba(255,255,255,.06); border-radius:14px; overflow:hidden; box-shadow:var(--shadow); }
    .part-card model-viewer { width:100%; height:auto; aspect-ratio: 5 / 3; display:block; background:#0a0f1f; }
    .part-cap { position:absolute; left:10px; bottom:10px; background:rgba(0,0,0,.45); padding:6px 10px; border-radius:10px; font-size:12px; color:#cbd5ff; border:1px solid rgba(255,255,255,.08); }
    .part-close { position:absolute; top:10px; right:10px; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.12); color:#e6e8ef; font-size:12px; padding:6px 10px; border-radius:10px; display:none; }
    .parts-grid.focused .part-card { display:none; }
    .parts-grid.focused .part-card.focused { display:block; grid-column:1 / -1; }
    .parts-grid.focused .part-card.focused model-viewer { aspect-ratio:auto; height:min(70vh, 720px); }
    .parts-grid.focused .part-card.focused .part-close { display:inline-block; }

    /* Code block (lightweight) */
    pre{ background:#0e162b; border:1px solid rgba(255,255,255,.06); padding:14px; border-radius:12px; overflow:auto }
    code{ color:#c7d2fe }

    /* Aside content */
    .aside h3{ margin:0 0 8px; font-size: 14px; text-transform: uppercase; letter-spacing:.4px; color:#cbd5ff }
    .aside .kv{ display:grid; grid-template-columns: 1fr; gap:8px }
    .kv div{ display:flex; justify-content:space-between; gap:12px; padding:8px 10px; border-radius:10px; background: rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06) }
    .kv span{ color: var(--muted) }
    .chip{ display:inline-block; padding:6px 10px; border-radius:999px; background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); margin:4px 6px 0 0; font-size:12px; color:#cbd5ff }
    .btn{ display:inline-block; margin-top:10px; background: linear-gradient(180deg, var(--brand), var(--brand-strong)); color:white; padding:10px 14px; border-radius:12px; box-shadow: var(--shadow) }

    footer{ color: var(--muted); font-size:14px; padding: 26px 0 8px }

    /* Modes/Features carousel */
    .modes { margin: 22px 0 10px; }
    .modes .intro { color: var(--muted); max-width: 70ch; }

    .modes-carousel {
      margin-top: 10px;
      background: #0a0f1f;
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .modes-head {
      display: grid;
      grid-template-columns: 40px 1fr 40px;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .modes-head .nav {
      display: grid; place-items: center;
      height: 38px; width: 38px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.199);
      background: rgba(255,255,255,.05);
      cursor: pointer;
      user-select: none;
      color:#495374
    }
    .modes-head .title {
      text-align: center;
      font-weight: 700;
      letter-spacing: .2px;
    }

    .modes-body {
      display: grid;
      gap: 14px;
    }
    @media (min-width: 980px){
      .modes-body { grid-template-columns: 1fr 1fr; align-items: start; }
    }

    .modes-code {
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      background: #0e162b;
      overflow: hidden;
    }
    .modes-code pre {
      margin: 0;
      max-height: 360px;
      overflow: auto;
      padding: 14px;
    }

    .modes-desc {
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      background: #0e162b;
      padding: 14px;
    }
    .modes-video {
      margin-top: 10px;
      background: #0a0f1f;
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      overflow: hidden;
    }

    /* Fade transition targets */
    .fadebox { opacity: 1; transition: opacity .28s ease; }
    .fadebox.is-changing { opacity: 0; }

    /* Optional: nicer inline code color if you add Prism later */
    .modes-code code { color: #c7d2fe; }

    /* Bigger overall sizing */
    .modes .title { font-size: clamp(18px, 2.2vw, 24px); }
    .modes-carousel { padding: 18px; }
    @media (min-width: 980px){
      .modes-body { grid-template-columns: 7fr 5fr; } /* code a bit wider than desc/video */
    }

    /* Code panel: bigger by default + expandable */
    .modes-code {
      position: relative;
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      background: #0e162b;
      overflow: hidden;
    }
    .modes-code pre {
      margin: 0;
      max-height: 420px;   /* bigger default */
      overflow: auto;
      padding: 16px;
      line-height: 1.55;
      font-size: 14px;
    }

    /* Transparent scrollbar track */
    .modes-code pre {
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.28) transparent; /* Firefox */
    }
    .modes-code pre::-webkit-scrollbar { width: 10px; height: 10px; }
    .modes-code pre::-webkit-scrollbar-track { background: transparent; }
    .modes-code pre::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,.18);
      border-radius: 10px;
      border: 2px solid transparent;  /* creates visual gap to track */
      background-clip: content-box;
    }

    /* Fade helper (already added for your section) */
    .fadebox { opacity: 1; transition: opacity .28s ease; }
    .fadebox.is-changing { opacity: 0; }

    /* Code toolbar (Expand/Collapse) */
    .modes-code .toolbar {
      position: absolute;
      right: 10px;
      bottom: 10px;
      display: flex;
      gap: 8px;
      z-index: 2;
    }
    .modes-code .toolbar button {
      background: rgba(255,255,255,.06);
      color: #e6e8ef;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      font-size: 12px;
      padding: 6px 10px;
      cursor: pointer;
    }

    /* Expand state */
    .modes-code.expanded pre {
      max-height: min(70vh, 720px);  /* tall when expanded */
    }

    /* Description + video: make the video area bigger */
    .modes-desc { padding: 16px; }
    .modes-video { margin-top: 12px; border-radius: 12px; }
    .modes-video video { width: 100%; height: auto; display: block; }

    /* Transparent scrollbar track for the Firmware code box */
    article pre {
      /* Firefox */
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.28) transparent;
    }
    article pre::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    article pre::-webkit-scrollbar-track {
      background: transparent;   /* transparent background */
    }
    article pre::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,.18);
      border-radius: 10px;
      border: 2px solid transparent; /* keeps a gap so track looks transparent */
      background-clip: content-box;
    }

    /* Two–image layout for “Why this design?” */
    .design-pics {
      display: grid;
      gap: 14px;
      margin: 14px 0 20px;
    }
    .design-pics img {
      width: 100%;
      height: auto;
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 14px;
      box-shadow: var(--shadow);
    }

    @media (min-width: 720px){
      .design-pics {
        grid-template-columns: 1fr 1fr;  /* side by side on wider screens */
      }
    }
    /* --- MOBILE FULL-BLEED HERO (prevents narrow hero, no zooming needed) --- */
    @media (max-width: 640px) {
      /* Make the hero span the full viewport width, independent of the .shell max-width */
      .hero {
        width: 100vw;
        margin-left: calc(50% - 50vw);
        margin-right: calc(50% - 50vw);
      }

      /* Keep media fluid and tall enough, no forced aspect */
      .hero-media {
        position: relative;
      }
      .hero-media img,
      .hero-media video {
        display: block;
        width: 100%;
        height: auto;      /* preserves intrinsic aspect (portrait stays portrait) */
        object-fit: cover; /* safe: fills width; change to 'contain' if you dislike cropping */
      }

      /* Optional: if you prefer not to show video on touch, uncomment:
      .hero-media video { display: none; }
      */
      
      /* Prevent any horizontal jiggle from full-bleed margins (doesn't affect pinch-zoom) */
      body { overflow-x: hidden; }
    }
    /* --- END MOBILE FULL-BLEED HERO --- */


      /* --- Photo Collage --- */
    .collage-section h2 { margin: 26px 0 10px; }

    .collage {
      column-gap: 12px;            /* spacing between columns */
      column-fill: balance;
      column-count: 1;             /* mobile */
    }

    @media (min-width: 600px)  { .collage { column-count: 2; } }
    @media (min-width: 900px)  { .collage { column-count: 3; } }
    @media (min-width: 1200px) { .collage { column-count: 4; } }

    .collage img {
      display: block;
      width: 100%;
      height: auto;
      margin: 0 0 12px;            /* vertical spacing between items */
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: var(--shadow);
      break-inside: avoid;         /* keep an image intact within a column */
      transform-origin: center;
      transition: transform .18s ease;
    }

    /* Subtle, randomized “not a perfect grid” vibes */
    .collage img.tiltL { transform: rotate(-0.6deg); }
    .collage img.tiltR { transform: rotate(0.6deg); }

    /* Straighten a touch on hover/focus (nice micro-interaction) */
    @media (hover:hover) and (pointer:fine) {
      .collage img:hover, .collage img:focus { transform: rotate(0deg) scale(1.01); }
    }

  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="crumb"><a href="../index.html">← Back to Projects</a> / Whiteboard Pen Plotter</div>
    </header>

    <!-- Hero -->
    <section class="hero">
      <div class="hero-media">
        <img src="../assets/images/whiteboard-hardware.jpg" alt="Whiteboard pen plotter hero placeholder" loading="lazy" decoding="async" />
        <video src="../assets/videos/0911(1).mp4" muted loop autoplay playsinline preload="metadata"></video>
      </div>
      <div class="hero-body">
        <div class="eyebrow">Build Log</div>
        <h1>Whiteboard Pen Plotter</h1>
        <p class="sub">A compact 2‑axis plotter designed for whiteboard drawings. This post captures goals, architecture, hardware choices, firmware approach, mechanical tuning, the problems I hit, and how I solved them. Images below are placeholders for now.</p>
      </div>
    </section>

    <div class="wrap">
      <!-- Main Article -->
      <article class="content" id="content">
        <h2>TL;DR</h2>
        <p>A wall-mounted CoreXY whiteboard plotter I designed and built from scratch. It uses custom 3D-printed parts, runs on GRBL, and supports multiple modes like free draw, image tracing, voice, and gesture control. I started with manual motor control before building my own G-code sender and refining the system for smooth, modular use. A hands-on project in hardware, software, and creative problem-solving.</p>

        <div class="figure">
          <img alt="Placeholder: plotter drawing on a whiteboard" loading="lazy" decoding="async" src="../assets/images/IMG_4142.jpg" />
          <div class="figcap">Figure 1 — Image of project.</div>
        </div>

        <h2>Goals</h2>
        <ul>
          <li><strong>Learn how CoreXY systems work</strong> by building one myself and adapting it to a vertical surface.</li>
          <li><strong>Keep the project low-cost</strong> by reusing the whiteboard itself as part of the rail system and 3D printing most structural components instead of buying expensive hardware.</li>
          <li><strong>Add fun and unique features</strong> like voice control, gesture input, and other interactive modes — to get the most out of the hardware and make the project stand out from typical plotters.</li>
        </ul>

        <h2>Architecture Overview</h2>
        <p>The whiteboard plotter is built around a CoreXY motion system, chosen for its light moving mass and high-speed accuracy. Motion is driven by two NEMA-17 stepper motors through GT2 belts and pulleys, with a compact micro-servo to lift and lower the pen. An Arduino Uno fitted with a CNC Shield and TMC stepper drivers provides the control electronics. On the firmware side, I run a custom GRBL streaming setup: instead of sending pre-generated files only, a lightweight host script streams G-code commands in real time, allowing both traditional plotted drawings and interactive modes. Together these mechanical, electronic, and software components form a precise, easily serviceable platform for large-scale whiteboard sketches.</p>
        <div class="figure">
          <img alt="Placeholder architecture diagram" loading="lazy" decoding="async" src="../assets/images/corexy.png" />
          <div class="figcap">Figure 2 — CoreXY architecture.</div>
        </div>

        <h2>Hardware</h2>
        <p>Short filler: 2 stepper motors, 1 servo, Arduino Uno, CNC shield, TMC drivers, plus a belt and pulleys.</p>
        <div class="figure" id="hardware-rotator">
          <img class="slide slideA show" alt="Hardware gallery image A" loading="lazy" decoding="async" src="https://picsum.photos/1200/720?random=1" />
          <img class="slide slideB" alt="Hardware gallery image B" loading="lazy" decoding="async" src="https://picsum.photos/1200/720?random=2" />
          <div class="figcap">Hardware gallery — cycling placeholders (5) with smooth fade.</div>
        </div>

        <!-- Modelled Parts (GLB with model-viewer) -->
        <section class="section" id="parts">
          <h2>Modelled Parts</h2>
          <p class="intro">I designed and printed brackets, idlers, mounts and hooks to route the belt, hold the pen and attach the plotter to the frame. Click a model to focus it; drag to rotate, pinch/scroll to zoom.</p>
          <div class="parts-grid" id="partsGrid">
            <div class="part-card" data-name="central pulley mount">
              <button class="part-close" type="button">Back</button>
              <span class="part-cap">Pen Mount</span>
              <model-viewer src="../assets/models/central_pulley.glb" camera-controls ar disable-zoom="false" autoplay></model-viewer>
            </div>
            <div class="part-card" data-name="motor mount">
              <button class="part-close" type="button">Back</button>
              <span class="part-cap">Belt Idler</span>
              <model-viewer src="../assets/models/motor_mount.glb" camera-controls ar disable-zoom="false" autoplay></model-viewer>
            </div>
            <div class="part-card" data-name="radial pulley mount">
              <button class="part-close" type="button">Back</button>
              <span class="part-cap">Motor Mount</span>
              <model-viewer src="../assets/models/radial_pulley.glb" camera-controls ar disable-zoom="false" autoplay></model-viewer>
            </div>
            <div class="part-card" data-name="pen holder">
              <button class="part-close" type="button">Back</button>
              <span class="part-cap">Wall Hook</span>
              <model-viewer src="../assets/models/servo holder v6.glb" camera-controls ar disable-zoom="false" autoplay></model-viewer>
            </div>
            <div class="part-card" data-name="full whiteboard">
              <button class="part-close" type="button">Back</button>
              <span class="part-cap">Cable Clip</span>
              <model-viewer src="../assets/models/whiteboard v8.glb" camera-controls ar disable-zoom="false" autoplay></model-viewer>
            </div>
          </div>
          <h3>Why this design?</h3>
            <p class="intro">
                The parts were deliberately designed to make use of the whiteboard’s own structure—such as the wall-mounting hooks—as rails. This approach cut cost and weight and kept the overall design compact. It did require accepting a slight loss of smoothness in the plotter’s motion, but that trade-off was worthwhile because the goal was never a high-precision machine. Every piece was shaped to fit seamlessly onto the whiteboard’s edges. 
            </p>

            <div class="design-pics">
              <img src="../assets/images/1.jpg" alt="Design illustration 1" loading="lazy" decoding="async" />
              <img src="../assets/images/2.jpg" alt="Design illustration 2" loading="lazy" decoding="async" />
            </div>

        </section>

        <h2>Firmware</h2>
        <p>Filler text: The firmware runs a small planner with trapezoidal acceleration and a queue of moves extracted from G‑code. Pen up/down timing uses a simple dwell and a solenoid/servo pin. This section will include real snippets and configuration tables.</p>
        <div class="code-wrap" id="fw-code">
          <pre><code class="language-cpp">
#!/usr/bin/env python3

"""
Pen Plotter Script for GRBL with Mode Selection
  • Image plotting
  • Freehand drawing
  • Text-to-image line sketch plotting
"""

import cv2
import numpy as np
from skimage.morphology import skeletonize
import matplotlib.pyplot as plt
import serial
import time
import math
from turtle import Screen, Turtle
import openai
import requests
from io import BytesIO
from PIL import Image

# === Configuration ===
IMAGE_PATH               = r"C:\Users\Eldho\Downloads\ChatGPT Image Sep 3, 2025, 02_37_06 PM.png"
OUTPUT_FILE              = r"C:\Users\Eldho\Documents\whiteboard code\mickey.gcode.txt"
SERIAL_PORT              = "COM3"       # e.g. 'COM3' or '/dev/ttyUSB0'; None to skip streaming
BAUDRATE                 = 115200       # GRBL default
OPENAI_API_KEY           = "YOUR_OPENAI_API_KEY"

# Image mode settings
SCALE                    = 0.05
THRESHOLD_VALUE          = 167
APPROX_FACTOR            = 0.0001
SHORT_PATH_THRESHOLD     = 5
MIN_MOVE                 = 0.5
SKIP_POINTS              = 1

# Motion settings
DRAW_FEED                = 6000
TRAVEL_FEED              = 6000
PEN_UP_CMD               = "M3 S80"
PEN_DOWN_CMD             = "M3 S180"

# Units
UNITS                    = "mm"
ABSOLUTE                 = True

# Preview
PREVIEW                  = True

# Draw mode settings
DRAW_AREA_WIDTH_MM       = 530
DRAW_AREA_HEIGHT_MM      = 350
SCREEN_WIDTH_PX          = 1325
SCREEN_HEIGHT_PX         = 875
SMOOTH_SEGMENT_MM        = 1.0

# === Core Setup ===
openai.api_key = "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"

# === Vectorization ===
def image_to_vector_coordinates(path):
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise FileNotFoundError(f"Cannot load image: {path}")
    h_px, w_px = img.shape
    _, bw = cv2.threshold(img, THRESHOLD_VALUE, 255, cv2.THRESH_BINARY_INV)
    skel = skeletonize(bw // 255).astype(np.uint8) * 255
    contours, _ = cv2.findContours(skel, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
    paths = []
    for cnt in contours:
        eps = APPROX_FACTOR * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, eps, True).squeeze()
        if approx.ndim == 1:
            approx = np.array([approx])
        if len(approx) <= 1:
            continue
        if len(approx) <= 10 and np.linalg.norm(approx[0] - approx[-1]) < SHORT_PATH_THRESHOLD:
            continue
        pts = approx.astype(float)
        pts[:,1] = h_px - pts[:,1]
        pts *= SCALE
        paths.append(pts)
    if not paths:
        return [], (h_px, w_px)
    ordered = [paths.pop(0)]
    while paths:
        last = ordered[-1][-1]
        best_idx, best_d, rev = 0, float('inf'), False
        for i, p in enumerate(paths):
            d0 = np.linalg.norm(last - p[0])
            d1 = np.linalg.norm(last - p[-1])
            if d0 < best_d:
                best_d, best_idx, rev = d0, i, False
            if d1 < best_d:
                best_d, best_idx, rev = d1, i, True
        p = paths.pop(best_idx)
        ordered.append(p[::-1] if rev else p)
    return ordered, (h_px, w_px)

# === Preview ===
def preview_paths(paths, shape_px):
    h_px, w_px = shape_px
    plt.figure(figsize=(8,8))
    plt.title("Path Preview")
    plt.imshow(
        np.zeros((h_px, w_px)),
        cmap='gray',
        extent=[0, w_px * SCALE, 0, h_px * SCALE]
    )
    for p in paths:
        plt.plot(p[:,0], p[:,1], '-')
    plt.axis('equal')
    plt.show()

# === G-code Generation ===
def paths_to_gcode(paths):
    lines = [
        'G21' if UNITS=='mm' else 'G20',
        'G90' if ABSOLUTE else 'G91',
        'G92 X0 Y0',
        PEN_UP_CMD
    ]
    for p in paths:
        x0, y0 = p[0]
        lines.append(f"G0 X{x0:.3f} Y{y0:.3f} F{TRAVEL_FEED}")
        lines.append(PEN_DOWN_CMD)
        px, py = x0, y0
        for x, y in p[::SKIP_POINTS]:
            if math.hypot(x - px, y - py) < MIN_MOVE:
                continue
            lines.append(f"G1 X{x:.3f} Y{y:.3f} F{DRAW_FEED}")
            px, py = x, y
        lines.append(PEN_UP_CMD)
    lines.append('M2')
    return '\n'.join(lines)

# === Time Estimation ===
def estimate_plot_time(paths):
    total = 0.0
    for p in paths:
        total += math.hypot(*p[0]) / TRAVEL_FEED * 60
        for (x0, y0), (x1, y1) in zip(p, p[1:]):
            total += math.hypot(x1 - x0, y1 - y0) / DRAW_FEED * 60
    return total / 60

# === Serial Streaming ===
def send_gcode(port, baud, gcode):
    with serial.Serial(port, baud, timeout=1) as ser:
        time.sleep(2)
        ser.flushInput()
        for line in gcode.splitlines():
            if not line:
                continue
            ser.write((line + '\n').encode())
            while not ser.readline().strip().lower().startswith(b'ok'):
                pass
            if line == PEN_DOWN_CMD or line == PEN_UP_CMD:
                time.sleep(0.2)
# === Text-to-Image ===
def text_to_image(prompt):
    system_msg = (
        "You are a prompt engineer generating very simple black-and-white line drawing (Only thin black outlines on a plain white background, no shading, no filled-in areas, no textures—just minimal, continuous black lines) prompts for DALL·E."
    )
    chat = openai.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": prompt}
        ]
    )
    dalle_prompt = chat.choices[0].message.content.strip()
    img_resp = openai.images.generate(
        model="dall-e-3",
        prompt=dalle_prompt,
        size="1024x1024",
        n=1
    )
    url = img_resp.data[0].url
    r = requests.get(url)
    img = Image.open(BytesIO(r.content)).convert('L')
    bw = img.point(lambda x: 255 if x < 128 else 0, mode='1')
    inv_bw = bw.point(lambda x: 255 - x, mode='1')
    path = "generated_line.png"

    inv_bw.save(path)
    print(f"Image saved: {path}")

    
    # ← ADD THIS PREVIEW BLOCK ↓
    plt.figure(figsize=(6,6))
    plt.imshow(inv_bw, cmap='gray')
    plt.title('AI-Generated Line Sketch')
    plt.axis('off')
    plt.show()
    # ← END PREVIEW

    return path

# === Mode Routines ===
def run_image_mode(image_path=IMAGE_PATH):
    paths, shape = image_to_vector_coordinates(image_path)
    if PREVIEW and paths:
        preview_paths(paths, shape)
    gcode = paths_to_gcode(paths)
    print(f"Estimated time: {estimate_plot_time(paths):.1f} min")
    with open(OUTPUT_FILE, 'w') as f:
        f.write(gcode)
    print(f"Saved G-code to {OUTPUT_FILE}")
    if SERIAL_PORT:
        print(f"Streaming to {SERIAL_PORT}@{BAUDRATE}...")
        send_gcode(SERIAL_PORT, BAUDRATE, gcode)
        print("Done.")


def run_draw_mode():
    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
    time.sleep(2)
    ser.flushInput()
    for cmd in [
        'G21' if UNITS=='mm' else 'G20',
        'G90' if ABSOLUTE else 'G91',
        'G92 X0 Y0',
        PEN_UP_CMD
    ]:
        ser.write((cmd + '\n').encode())
        while not ser.readline().strip().lower().startswith(b'ok'):
            pass
    pen = False
    last_mx = (SCREEN_WIDTH_PX / 2) * (DRAW_AREA_WIDTH_MM / SCREEN_WIDTH_PX)
    last_my = (SCREEN_HEIGHT_PX / 2) * (DRAW_AREA_HEIGHT_MM / SCREEN_HEIGHT_PX)
    scale_x = DRAW_AREA_WIDTH_MM / SCREEN_WIDTH_PX
    scale_y = DRAW_AREA_HEIGHT_MM / SCREEN_HEIGHT_PX

    def send(cmd):
        ser.write((cmd + '\n').encode())
        while not ser.readline().strip().lower().startswith(b'ok'):
            pass

    screen = Screen()
    screen.setup(SCREEN_WIDTH_PX, SCREEN_HEIGHT_PX)
    drawer = Turtle('turtle')
    drawer.speed('fastest')

    def toggle(x, y):
        nonlocal pen
        if not pen:
            send(PEN_DOWN_CMD)
            pen = True
        else:
            send(PEN_UP_CMD)
            pen = False

    def drag(x, y):
        nonlocal pen, last_mx, last_my
        drawer.ondrag(None)
        drawer.goto(x, y)
        drawer.ondrag(drag)
        mx = (x + SCREEN_WIDTH_PX / 2) * scale_x
        my = (y + SCREEN_HEIGHT_PX / 2) * scale_y
        dist = math.hypot(mx - last_mx, my - last_my)
        steps = max(1, int(dist / SMOOTH_SEGMENT_MM))
        for i in range(1, steps+1):
            ix = last_mx + (mx - last_mx) * i / steps
            iy = last_my + (my - last_my) * i / steps
            send(f"G{'1' if pen else '0'} X{ix:.3f} Y{iy:.3f} F{DRAW_FEED if pen else TRAVEL_FEED}")
        last_mx, last_my = mx, my

    screen.onclick(toggle, btn=3)
    drawer.ondrag(drag)
    screen.mainloop()
    ser.close()


def run_text2img_mode():
    prompt = input("Enter text prompt: ")
    img_path = text_to_image(prompt)
    run_image_mode(image_path=img_path)

# === Main ===
def main():
    print("Select mode: 1) Image plot  2) Freehand draw  3) Text-to-image plot")
    c = input("Choice: ").strip()
    if c == '1':
        run_image_mode()
    elif c == '2':
        run_draw_mode()
    elif c == '3':
        run_text2img_mode()
    else:
        print("Invalid choice.")

if __name__ == '__main__':
    main()
          </code></pre>
          <div class="fade"></div>
          <div class="toolbar">
            <button type="button" data-action="toggle">Expand</button>
          </div>
        </div>
        <!-- Modes / Features -->
          <section class="modes" id="modes">
            <h2>Modes</h2>
            <p class="intro">Different operating modes I implemented in firmware. Use the arrows to browse; the code types in, the description updates, and a short video demo appears.</p>

            <div class="modes-carousel" aria-live="polite">
              <div class="modes-head">
                <button class="nav" id="modePrev" aria-label="Previous mode">⟨</button>
                <div class="title" id="modeTitle">Mode Title</div>
                <button class="nav" id="modeNext" aria-label="Next mode">⟩</button>
              </div>

              <div class="modes-body">
                <!-- Left: Code -->
                <div class="modes-code fadebox" id="modesCodeBox">
                  <pre><code id="modeCode">// code will type here</code></pre>
                  <div class="toolbar">
                    <button type="button" id="modeExpandBtn">Expand</button>
                  </div>
                </div>

                <!-- Right: Description only -->
                <div class="modes-desc fadebox" id="modeDesc">
                  <p>Description will update here.</p>
                </div>
              </div>

              <!-- Video now spans full width below both columns -->
              <div class="modes-video fadebox" id="modeVideoBox">
                <video id="modeVideo" controls preload="metadata" width="100%" height="auto">
                  <source id="modeVideoSrc" src="" type="video/mp4">
                  Your browser does not support the video tag.
                </video>
                <img id="modeImage" src="" alt="" style="display:none;width:100%;height:auto;" />

              </div>

          </section>


        <h2>Interface</h2>
        <p>I built a custom GUI using tKinter to upload, resize and position drawings. The different modes can be switched in the GUI or via AI interpreted voice commands</p>

        <div class="figure">
          <img alt="Placeholder: close-up of carriage" loading="lazy" decoding="async" src="../assets/images/gui.jpg" />
          <div class="figcap">Figure 3 — GUI.</div>
        </div>
        <h2>Results</h2>
        <p>The custom-built pen plotter successfully meets and extends its original goal of producing accurate, high-quality line drawings comparable to those from a commercial plotter. Integrated directly into the whiteboard—without the need for any external framework or bulky infrastructure—it can be mounted securely on a wall and operated with minimal noise. Its open, fully customisable control software allows new modes and features to be added without the limitations of conventional tools such as GRBL or Universal G-code Sender. Advanced capabilities include AI-based image processing to convert any picture into a line drawing for plotting, real-time hand-tracking so sketches made on a computer are reproduced instantly on the whiteboard, and voice-activated commands that can both generate AI-created images and instruct the plotter to draw them. These results demonstrate a versatile, low-noise system that goes well beyond the functionality of a typical pen plotter.</p>

        <!-- Photo Collage -->
        <section id="photo-collage" class="collage-section">
          <h2>Photo Collage</h2>
          <div class="collage" id="collage">
            <!-- Add/remove images freely; each will slot in automatically -->
            <img src="../assets/images/IMG_4492.JPG" alt="Plotter drawing 1" loading="lazy" decoding="async">
            <img src="../assets/images/IMG_4493.JPG" alt="Motor detail" loading="lazy" decoding="async">
            <img src="../assets/images/IMG_4495.PNG" alt="Pulleys & cable" loading="lazy" decoding="async">
            <img src="../assets/images/IMG_4494.JPG" alt="Electronics" loading="lazy" decoding="async">
            <img src="../assets/images/IMG_4496.JPG" alt="Electronics" loading="lazy" decoding="async">
            <!-- Add more <img> lines; no fixed count needed -->
          </div>
        </section>

      </article>

      <!-- Sidebar / meta -->
      <aside class="aside" aria-label="Project metadata">
        <h3>Project</h3>
        <div class="kv">
          <div><span>Status</span><strong>In progress</strong></div>
          <div><span>Started</span><strong>2025‑03</strong></div>
          <div><span>Area</span><strong>Mechatronics</strong></div>
        </div>
        <h3 style="margin-top:14px">Tech</h3>
        <div>
          <span class="chip">NEMA steppers</span>
          <span class="chip">TMC drivers</span>
          <span class="chip">Arduino/Pico</span>
          <span class="chip">G‑code</span>
        </div>
        <h3 style="margin-top:14px">Links</h3>
        <a class="btn" href="#" onclick="alert('Add GitHub link later')">GitHub (soon)</a>
      </aside>
    </div>

    <footer>© <span id="year"></span> Eldho <B></B>iju • Bristol, UK</footer>
  </div>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();

    // Focus / Back for Modelled Parts
    (function(){
      const grid = document.getElementById('partsGrid');
      if (!grid) return;

      grid.addEventListener('click', (e) => {
        const back = e.target.closest('.part-close');
        if (back) {
          grid.classList.remove('focused');
          grid.querySelectorAll('.part-card').forEach(c => c.classList.remove('focused'));
          return;
        }
        const card = e.target.closest('.part-card');
        if (card) {
          grid.classList.add('focused');
          grid.querySelectorAll('.part-card').forEach(c => c.classList.remove('focused'));
          card.classList.add('focused');
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          grid.classList.remove('focused');
          grid.querySelectorAll('.part-card').forEach(c => c.classList.remove('focused'));
        }
      });
    })();


    // Hardware image rotator (5 placeholders) — crossfade
    (function(){
      const A = document.querySelector('#hardware-rotator .slideA');
      const B = document.querySelector('#hardware-rotator .slideB');
      if(!A || !B) return;
      const imgs = [
        "../assets/images/servo.jpg",
        "../assets/images/pulleys_cable.jpg",
        "../assets/images/motor.jpg",
        "../assets/images/IMG_0800.jpg",
        "../assets/images/electronics.jpg"
      ];
      // Preload all to avoid flicker
      imgs.forEach(src => { const im = new Image(); im.src = src; });
      let i = 1; // A has 0, B has 1 initially
      let showA = true;
      setInterval(()=>{
        i = (i+1) % imgs.length; // next image index
        const next = imgs[i];
        const incoming = showA ? B : A;
        const outgoing = showA ? A : B;
        incoming.src = next;
        // Force next frame before toggling for smoother CSS transition
        requestAnimationFrame(()=>{
          incoming.classList.add('show');
          outgoing.classList.remove('show');
          showA = !showA;
        });
      }, 2500);
      // Ensure images always fill the frame
      // (Handled by CSS: object-fit: cover; height: 100%)
    })();
  </script>

  <script>
    (function(){
      const wrap = document.getElementById('fw-code');
      if(!wrap) return;
      const btn = wrap.querySelector('[data-action="toggle"]');

      const setLabel = () => { btn.textContent = wrap.classList.contains('expanded') ? 'Collapse' : 'Expand'; };
      setLabel();

      btn.addEventListener('click', () => {
        wrap.classList.toggle('expanded');
        setLabel();
      });

      // Optional: Esc to collapse
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape' && wrap.classList.contains('expanded')){
          wrap.classList.remove('expanded');
          setLabel();
        }
      });
    })();
  </script>


  <script>
    document.querySelectorAll('model-viewer').forEach((mv) => {
      mv.addEventListener('load', () => {
        console.log('✅ loaded', mv.getAttribute('src'));
      });
      mv.addEventListener('error', (e) => {
        console.error('❌ model-viewer error for', mv.getAttribute('src'), e.detail?.message || e);
      });
    });
  </script>


  <script type="module">
    import * as MeshoptDecoder from "https://unpkg.com/@meshoptimizer/meshopt_decoder/meshopt_decoder.module.js";
    // expose for <model-viewer>
    window.MeshoptDecoder = MeshoptDecoder;
  </script>

  
  <!-- model-viewer web component -->
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

  <script>
    // Focus / Back behavior for Modelled Parts
    (function(){
      const grid = document.getElementById('partsGrid');
      if(!grid) return;
      grid.addEventListener('click', (e)=>{
        const back = e.target.closest('.part-close');
        if(back){ grid.classList.remove('focused'); grid.querySelectorAll('.part-card').forEach(c=>c.classList.remove('focused')); return; }
        const card = e.target.closest('.part-card');
        if(card){ grid.classList.add('focused'); grid.querySelectorAll('.part-card').forEach(c=>c.classList.remove('focused')); card.classList.add('focused'); }
      });
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ grid.classList.remove('focused'); grid.querySelectorAll('.part-card').forEach(c=>c.classList.remove('focused')); } });
    })();
  </script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    // Optional: preload a few common languages
    Prism.plugins.autoloader.languages_path = 'https://unpkg.com/prismjs@1.29.0/components/';
  </script>
  <script>
    // --- Modes/Features carousel data ---
      const MODES = [
                {
          name: "Hand-Tracking",
          lang: "cpp",
          code: `import cv2, time, serial, mediapipe as mp, math

ser = serial.Serial("COM5", 115200, timeout=1); time.sleep(2)
for cmd in ["G21","G90","G92 X0 Y0","M5"]:   # init + pen up
    ser.write((cmd+"\n").encode()); ser.readline()

hands = mp.solutions.hands.Hands(max_num_hands=1)
cap = cv2.VideoCapture(0); pen = False

def send(cmd): ser.write((cmd+"\n").encode()); ser.readline()

while True:
    ok, frame = cap.read();  if not ok: break
    res = hands.process(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    if res.multi_hand_landmarks:
        lm = res.multi_hand_landmarks[0].landmark
        ix, iy = lm[8].x, lm[8].y                # index fingertip
        tx, ty = lm[4].x, lm[4].y                # thumb tip
        if math.hypot(ix-tx, iy-ty) < 0.06:      # pinch -> toggle pen
            pen = not pen; send("M3" if pen else "M5")
        x, y = ix*400, iy*300                    # map to mm
        send(f"G{'1' if pen else '0'} X{x:.1f} Y{y:.1f} F2000")
    if cv2.waitKey(1) & 0xFF == ord('q'): break
`,
          desc: "Track the users hand using a webcam mounted to the side of the board, the coordinates are mapped to the whiteboard and sent in real time. I added gesture tracking for pen up and pen down aswell. Powered by Google's MediaPipe Library",
          video: "../assets/videos/0924 (3).mp4" // <- replace with your file or keep blank
        },
        {
          name: "Vector Plot (G-code)",
          lang: "cpp",
          code: `import serial, time

def send_gcode(port: str, baud: int, gcode_lines: list[str]):
    """
    Open the GRBL serial port and stream a list of G-code commands.
    """
    with serial.Serial(port, baud, timeout=1) as ser:
        time.sleep(2)                          # allow GRBL to reset
        ser.write(b"\r\n\r\n"); time.sleep(2)   # wake & flush
        ser.flushInput()

        for line in gcode_lines:
            cmd = line.strip() + '\n'
            ser.write(cmd.encode())
            grbl_out = ser.readline().decode().strip()
            print(f">> {cmd.strip()}   [{grbl_out}]")

# Example usage:
# send_gcode("/dev/ttyUSB0", 115200, ["G21", "G90", "G0 X10 Y10", "M3"])
`,
          desc: "Standard G-code streaming: paths are generated offline  and sent over serial to GRBL. Good for precise drawings.",
          video: "../assets/videos/0911(1).mp4" // <- replace with your file or keep blank
        },
        {
          name: "Live Sketch",
          lang: "cpp",
          code: `def image_to_vector_coordinates(path):
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    _, bw = cv2.threshold(img, THRESHOLD_VALUE, 255, cv2.THRESH_BINARY_INV)
    skel = skeletonize(bw // 255).astype(np.uint8) * 255
    contours, _ = cv2.findContours(skel, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

    paths = []
    for cnt in contours:
        eps = APPROX_FACTOR * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, eps, True).squeeze()
        if approx.ndim == 1 or len(approx) <= 1: continue
        pts = approx.astype(float)
        pts[:,1] = img.shape[0] - pts[:,1]      # flip Y
        pts *= SCALE
        paths.append(pts)
    return paths, img.shape

def run_image_mode(image_path):
    paths, shape = image_to_vector_coordinates(image_path)
    if PREVIEW and paths: preview_paths(paths, shape)
    gcode = paths_to_gcode(paths)
    if SERIAL_PORT: send_gcode(SERIAL_PORT, BAUDRATE, gcode)
`,
          desc: "Real-time control. Great for testing mechanics and for.",
          video: "../assets/videos/0924.mp4"
        },
        {
          name: "image to plot",
          lang: "cpp",
          code: `def image_to_vector_coordinates(path):
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    _, bw = cv2.threshold(img, THRESHOLD_VALUE, 255, cv2.THRESH_BINARY_INV)
    skel = skeletonize(bw // 255).astype(np.uint8) * 255
    contours, _ = cv2.findContours(skel, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

    paths = []
    for cnt in contours:
        eps = APPROX_FACTOR * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, eps, True).squeeze()
        if approx.ndim == 1 or len(approx) <= 1: continue
        pts = approx.astype(float)
        pts[:,1] = img.shape[0] - pts[:,1]      # flip Y
        pts *= SCALE
        paths.append(pts)
    return paths, img.shape

def run_image_mode(image_path):
    paths, shape = image_to_vector_coordinates(image_path)
    if PREVIEW and paths: preview_paths(paths, shape)
    gcode = paths_to_gcode(paths)
    if SERIAL_PORT: send_gcode(SERIAL_PORT, BAUDRATE, gcode)
`,
          desc: "Converts images to a line drawing using a ChatGpt API then convereted to G-code. Other than the API, everything is done in the whiteboard code itself, no outside programs used.",
          image: "../assets/images/Untitled design.jpg"
        }
      ];

      // --- Helpers ---
      const el = (id) => document.getElementById(id);
      const titleEl   = el('modeTitle');
      const codeEl    = el('modeCode');
      const descBox   = el('modeDesc');
      const videoBox  = el('modeVideoBox');
      const videoEl   = el('modeVideo');
      const videoSrc  = el('modeVideoSrc');
      const codeBox   = document.querySelector('.modes-code');

      let idx = 0;
      let typerTimer;

      function setChanging(on) {
        // add/remove fade class to all three boxes
        codeBox.classList.toggle('is-changing', on);
        descBox.classList.toggle('is-changing', on);
        videoBox.classList.toggle('is-changing', on);
      }

      function typeCode(text, langHint) {
        // simple typewriter; clears then types
        clearInterval(typerTimer);
        codeEl.textContent = '';           // reset
        let i = 0;
        const speed = 12;                  // chars per tick
        typerTimer = setInterval(() => {
          codeEl.textContent = text.slice(0, i += speed);
          if (i >= text.length) clearInterval(typerTimer);
          // If you later add Prism, you can re-highlight here:
          // if (window.Prism) Prism.highlightElement(codeEl);
        }, 20);
      }

      function renderMode(i) {
        const m = MODES[i];
        setChanging(true);

        // Delay to let fade-out happen
        setTimeout(() => {
          titleEl.textContent = m.name;

          // Code
          codeEl.className = '';                 // reset classes
          codeEl.classList.add(`language-${m.lang || 'cpp'}`);
          typeCode(m.code, m.lang);

          // Description
          descBox.innerHTML = `<p>${m.desc}</p>`;

          // Video
          const imgEl = document.getElementById('modeImage');

          if (m.video) {
            // show video, hide image
            videoBox.style.display = '';
            videoEl.style.display = '';
            imgEl.style.display = 'none';

            videoSrc.src = m.video;
            videoEl.load();

          } else if (m.image) {
            // show image, hide video
            videoEl.pause();
            videoEl.style.display = 'none';
            videoSrc.src = '';
            imgEl.src = m.image;
            imgEl.style.display = 'block';

          } else {
            // nothing to show
            videoEl.style.display = 'none';
            imgEl.style.display = 'none';
          }


          // Fade back in
          setChanging(false);
        }, 160);
      }

      // Init UI
      renderMode(idx);

      // Nav
      document.getElementById('modePrev').addEventListener('click', () => {
        idx = (idx - 1 + MODES.length) % MODES.length;
        renderMode(idx);
      });
      document.getElementById('modeNext').addEventListener('click', () => {
        idx = (idx + 1) % MODES.length;
        renderMode(idx);
      });
      // Optional keyboard arrows
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft')  document.getElementById('modePrev').click();
        if (e.key === 'ArrowRight') document.getElementById('modeNext').click();
      });
    </script>
    <script>
      // Expand/Collapse for the Modes code panel
      (function(){
        const box = document.getElementById('modesCodeBox');
        const btn = document.getElementById('modeExpandBtn');
        if(!box || !btn) return;

        function setLabel(){
          btn.textContent = box.classList.contains('expanded') ? 'Collapse' : 'Expand';
        }
        setLabel();

        btn.addEventListener('click', ()=>{
          box.classList.toggle('expanded');
          setLabel();
        });

        // Optional: collapse with Esc
        document.addEventListener('keydown', (e)=>{
          if(e.key === 'Escape' && box.classList.contains('expanded')){
            box.classList.remove('expanded');
            setLabel();
          }
        });
      })();
    </script>

    <script>
      (function(){
        const grid = document.getElementById('collage');
        if (!grid) return;
        const imgs = Array.from(grid.querySelectorAll('img'));
        imgs.forEach((img) => {
          const r = Math.random();
          if (r < 0.25) img.classList.add('tiltL');
          else if (r < 0.50) img.classList.add('tiltR');
          // else: keep straight for variety
        });
      })();
    </script>

</body>
</html>
